/********************************************************************************************
*** 文件名：Decode.c 
*** 描  述：用一个外部中断IO脚配合定时器0实现对2262系列编码信号进行软解码, PT2262的 
        输出信号经LM358整形放大后,由单片机P3.2口输入,作为单片机的外部中断源。 
*** 编  码：A0 -- A11 中的每bit用2bit表示：0码：00 ；1码：11 
*** 硬  件：AD1501发射模块、LM358+R25.接收模块、STC15W404AS单片机 
*** 晶  振：18.432MHz 
*** 日  期：2017-12-12 (zqjun@HK) 
*** 说  明： 
    1、AD1501输出编码包括20位地址码、4位数据码、1位同步码,共25位 
    2、四个振荡周期为1个编码计时单位，记作T,除同步码外,编码中只有2种类别的组合 
       脉冲取名长脉冲和短脉冲，其中：长脉冲由3T高电平、1T低电平组成；
	   短脉冲由1T高电平、3T低电平组成。 
    3、同步码，由1T高电平31T低电平组合（实际测试同步码低电平宽度基本在10ms以上)。 
    4、只需测量低电平或者高电平长短，即可知是长还是短脉冲，超过12T时间没有
	   脉冲变化就有可能是同步码。 
***********************************************************************************************/  
   
#include "wireless.h"
#include "get_key.h"

#define FOSC 18432000L
//#define T1MS (65536-FOSC/1000)      //1T模式
#define T100uS (65536-FOSC/12/10000) //12T模式


sbit ext_in = P3^2;
 
//unsigned char receive[3]={1,2,3};//接收缓存区,receive[0]：A0-A3;receive[1]：A4-A7;
						//receive[2]：D3-D0
unsigned int l_times;
unsigned int h_times = 1;
unsigned int count;
unsigned int times;
//unsigned int channel_all_times;



/*****************************************************************
*********功能：定时器0中断初始化函数,10ms
******************************************************************/
void timer0_init() 
{
/*
	AUXR &= 0x7F;	//定时器时钟12T模式	  10毫秒@6.000MHz
	TMOD &= 0xF0;	//设置定时器模式
	TL0 = 0x78;		//设置定时初值
	TH0 = 0xEC;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0 = 1;		//打开定时器0中断
*/

/*
	AUXR &= 0x7F;	//定时器时钟12T模式	10毫秒@11.0592MHz
	TMOD &= 0xF0;	//设置定时器模式
	TL0 = 0x00;		//设置定时初值
	TH0 = 0xDC;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0 = 1;		//打开定时器0中断
*/

    AUXR &= 0x7F;		//定时器时钟12T模式	 10毫秒@11.0592MHz
	TMOD &= 0xF0;		//设置定时器模式	
	TL0 = 0x00;		//设置定时初值
	TH0 = 0xC4;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0 = 1;		//打开定时器0中断
//	PT0 =1;			 //中断优先级高
}

/*****************************************************************
*********功能：定时器0中断函数
******************************************************************/

void tm0_isr() interrupt 1 // using 1
{
	      num++;
		  //channel_4 = 1;
		  	if (	channel_5 ==1)	  //警铃点动处理
	{
		if (num > 20)//大于200ms,则认为不是同一次按下(相当于按下的两次是相互独立的)
		{
			channel_5 = 0;
		//	ring=0;
		}
	}

/*
	if ((mode == 0x3c) && (Date == 0x0C))	//混合模式中的点动
	{
		if (num > 20)		  //实现点动
		{
//			channel_init();
			P3 &= 0x7F;	  //  0111 1111，即让channel_2 = 0;就是P3^7口
		}
	}
*/	
	switch (mode)		//混合模式中的点动处理
	{
	 	case 0x02:		//上下左右都是点动	  
			if ((	channel_4 ==1) ||(channel_2 == 1) ||(channel_3 == 1) ||(channel_6 == 1))
			{
				if (num > 20)
				{
					channel_4 = 0;
					channel_2 = 0;
					channel_3 = 0;
					channel_6 = 0;
				}
			}
			break;
	 	case 0x06:		//上下点动时
			if ((channel_3 == 1) ||(channel_6 == 1))
			{
				if (num > 20)
				{
					channel_3 = 0;
					channel_6 = 0;
				}
			}
			break;
		case 0x01:		//左右点动
			if ((channel_2 == 1) ||(channel_4 == 1))
			{
				if (num > 20)
				{
					channel_4 = 0;
					channel_2 = 0;
				}
			}
			  case 0x0e:		//上下点动时
			if ((channel_3 == 1) ||(channel_6 == 1))
			{
				if (num > 20)
				{
					channel_3 = 0;
					channel_6 = 0;
				}
			}
			break;
		default:
            break;
	}    
           
}



/*****************************************************************
*********功能：定时器2中断初始化函数,10us
******************************************************************/
void timer2_init()		
{
/*
	AUXR |= 0x04;	//定时器时钟1T模式	10微秒@6.000MHz
	T2L = 0xC4;		//设置定时初值
	T2H = 0xFF;		//设置定时初值
	AUXR |= 0x10;	//定时器2开始计时
	IE2 |= 0x04; 	//开定时器2中断
*/

/*
	AUXR |= 0x04;	//定时器时钟1T模式	 10微秒@11.0592MHz
	T2L = 0x91;		//设置定时初值
	T2H = 0xFF;		//设置定时初值
	AUXR |= 0x10;	//定时器2开始计时
	IE2 |= 0x04; 	//开定时器2中断
*/

	AUXR |= 0x04;	//定时器时钟1T模式	10微秒@18.432MHz
	T2L = 0x48;		//设置定时初值
	T2H = 0xFF;		//设置定时初值
	AUXR |= 0x10;	//定时器2开始计时
	IE2 |= 0x04; 	//开定时器2中断
	


}

/*****************************************************************
*********功能：定时器2中断函数
******************************************************************/
void tm2_isr() interrupt 12  using 2
{
	count++;
//	channel_all_times++;
	


}
/*****************************************************************
*********功能：外部中断0初始化函数
******************************************************************/
void ext0_init()
{
	ext_in = 1;    
    data0 = 0;
    data1 = 0;
	IT0 = 0;	//上升沿和下降沿都触发中断
	EX0 = 1;
	PX0 = 0;

//	EA = 1;	
}
 
/********************************************************************* 
************** 功能: 外部中断0服务函数，实现对1501解码 *************** 
************** 中断功能开启后，边沿触发中断进入此函数 **************** 
*********************************************************************/  

void  exint0() interrupt 0 // using 0	//1501周期35ms   同步码持续8.5ms
{	
    // static bit L=0;
     static bit H=0;
						//宅脉冲280us   宽脉冲880us
    if (ext_in)
      {	 
	     if(h_times<20)
	       return; 
	  
	       l_times = count;
           count = 0; 

		   if(l_times<20)
		   {
		     count+=l_times;
			 return;
		   }

//		   if (l_times > 3000)
//         {
//            times = 0;
//            data0 = 0;
//            data1 = 0;
//            l_times = 0;
//            h_times = 0;
//            return ;
//         } 
		  
		
	   	 



	if (l_times / h_times >= 25||(l_times>700&&H==1))
       {		
              if (times != 24)
              {
                   times = 0;
                   data0 = 0;
                   data1 = 0; 
				           H = 0;			  				 
               }
        }
    else
	if (l_times / h_times >=2)
       {
            if (times < 24)
            {
                data0 = data0 << 1;
            }
            else
            {
                data1 = data1 << 1;
            }
            times ++;
          }
        //低电平时间小于高电平时间，则该位数据为1
        else
		  	 if(h_times / l_times >=2)
          {
            if (times < 24)
            {
                data0 = (data0 << 1) + 1;
            }
            else
            {
                data1 = (data1 << 1) + 1;
            }
            times ++;
          }
        l_times = 0;
        h_times = 0;
       	if(study)
		{
		  if (times >= 48)

           { 
		   	EX0=0;
			key=1 ;
			times = 0;
           }
		
		}
		else
			{
              if (times >= 24)
			  { 
		        data1 = data0;
			    key=1 ;
		     	EX0=0;
                times = 0;
               }
		}
       
	  }
	  else
	 {	
	    h_times = count;
        count = 0;
		if(h_times>150)
		   {   
		       h_times=0;
			     H = 1;
	         return;
		    }
	
		if(h_times<20)
		{
		count+=h_times;	
		}

     }



   
}

