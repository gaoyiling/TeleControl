C51 COMPILER V9.59.0.0   WIRELESS                                                          03/25/2019 10:21:40 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE WIRELESS
OBJECT MODULE PLACED IN ..\OBJ\wireless.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\WIRELESS\wireless.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\GETKEY;..\WIRE
                    -LESS;..\UART) DEBUG OBJECTEXTEND PRINT(..\Listings\wireless.lst) TABS(2) OBJECT(..\OBJ\wireless.obj)

line level    source

   1          /********************************************************************************************
   2          *** 文件名：Decode.c 
   3          *** 描  述：用一个外部中断IO脚配合定时器0实现对2262系列编码信号进行软解码, PT2262的 
   4                  输出信号经LM358整形放大后,由单片机P3.2口输入,作为单片机的外部中断源。 
   5          *** 编  码：A0 -- A11 中的每bit用2bit表示：0码：00 ；1码：11 
   6          *** 硬  件：AD1501发射模块、LM358+R25.接收模块、STC15W404AS单片机 
   7          *** 晶  振：18.432MHz 
   8          *** 日  期：2017-12-12 (zqjun@HK) 
   9          *** 说  明： 
  10              1、AD1501输出编码包括20位地址码、4位数据码、1位同步码,共25位 
  11              2、四个振荡周期为1个编码计时单位，记作T,除同步码外,编码中只有2种类别的组合 
  12                 脉冲取名长脉冲和短脉冲，其中：长脉冲由3T高电平、1T低电平组成；
  13               短脉冲由1T高电平、3T低电平组成。 
  14              3、同步码，由1T高电平31T低电平组合（实际测试同步码低电平宽度基本在10ms以上)。 
  15              4、只需测量低电平或者高电平长短，即可知是长还是短脉冲，超过12T时间没有
  16               脉冲变化就有可能是同步码。 
  17          ***********************************************************************************************/  
  18             
  19          #include "wireless.h"
  20          #include "get_key.h"
  21          
  22          #define FOSC 18432000L
  23          //#define T1MS (65536-FOSC/1000)      //1T模式
  24          #define T100uS (65536-FOSC/12/10000) //12T模式
  25          
  26          
  27          sbit ext_in = P3^2;
  28           
  29          //unsigned char receive[3]={1,2,3};//接收缓存区,receive[0]：A0-A3;receive[1]：A4-A7;
  30                      //receive[2]：D3-D0
  31          unsigned int l_times;
  32          unsigned int h_times = 1;
  33          unsigned int count;
  34          unsigned int times;
  35          //unsigned int channel_all_times;
  36          
  37          
  38          
  39          /*****************************************************************
  40          *********功能：定时器0中断初始化函数,10ms
  41          ******************************************************************/
  42          void timer0_init() 
  43          {
  44   1      /*
  45   1        AUXR &= 0x7F; //定时器时钟12T模式   10毫秒@6.000MHz
  46   1        TMOD &= 0xF0; //设置定时器模式
  47   1        TL0 = 0x78;   //设置定时初值
  48   1        TH0 = 0xEC;   //设置定时初值
  49   1        TF0 = 0;    //清除TF0标志
  50   1        TR0 = 1;    //定时器0开始计时
  51   1        ET0 = 1;    //打开定时器0中断
  52   1      */
  53   1      
  54   1      /*
C51 COMPILER V9.59.0.0   WIRELESS                                                          03/25/2019 10:21:40 PAGE 2   

  55   1        AUXR &= 0x7F; //定时器时钟12T模式 10毫秒@11.0592MHz
  56   1        TMOD &= 0xF0; //设置定时器模式
  57   1        TL0 = 0x00;   //设置定时初值
  58   1        TH0 = 0xDC;   //设置定时初值
  59   1        TF0 = 0;    //清除TF0标志
  60   1        TR0 = 1;    //定时器0开始计时
  61   1        ET0 = 1;    //打开定时器0中断
  62   1      */
  63   1      
  64   1          AUXR &= 0x7F;   //定时器时钟12T模式  10毫秒@11.0592MHz
  65   1        TMOD &= 0xF0;   //设置定时器模式  
  66   1        TL0 = 0x00;   //设置定时初值
  67   1        TH0 = 0xC4;   //设置定时初值
  68   1        TF0 = 0;    //清除TF0标志
  69   1        TR0 = 1;    //定时器0开始计时
  70   1        ET0 = 1;    //打开定时器0中断
  71   1      //  PT0 =1;      //中断优先级高
  72   1      }
  73          
  74          /*****************************************************************
  75          *********功能：定时器0中断函数
  76          ******************************************************************/
  77          
  78          void tm0_isr() interrupt 1 // using 1
  79          {
  80   1              num++;
  81   1            //channel_4 = 1;
  82   1              if (  channel_5 ==1)    //警铃点动处理
  83   1        {
  84   2          if (num > 20)//大于200ms,则认为不是同一次按下(相当于按下的两次是相互独立的)
  85   2          {
  86   3            channel_5 = 0;
  87   3          //  ring=0;
  88   3          }
  89   2        }
  90   1      
  91   1      /*
  92   1        if ((mode == 0x3c) && (Date == 0x0C)) //混合模式中的点动
  93   1        {
  94   1          if (num > 20)     //实现点动
  95   1          {
  96   1      //      channel_init();
  97   1            P3 &= 0x7F;   //  0111 1111，即让channel_2 = 0;就是P3^7口
  98   1          }
  99   1        }
 100   1      */  
 101   1        switch (mode)   //混合模式中的点动处理
 102   1        {
 103   2          case 0x02:    //上下左右都是点动    
 104   2            if (( channel_4 ==1) ||(channel_2 == 1) ||(channel_3 == 1) ||(channel_6 == 1))
 105   2            {
 106   3              if (num > 20)
 107   3              {
 108   4                channel_4 = 0;
 109   4                channel_2 = 0;
 110   4                channel_3 = 0;
 111   4                channel_6 = 0;
 112   4              }
 113   3            }
 114   2            break;
 115   2          case 0x06:    //上下点动时
 116   2            if ((channel_3 == 1) ||(channel_6 == 1))
C51 COMPILER V9.59.0.0   WIRELESS                                                          03/25/2019 10:21:40 PAGE 3   

 117   2            {
 118   3              if (num > 20)
 119   3              {
 120   4                channel_3 = 0;
 121   4                channel_6 = 0;
 122   4              }
 123   3            }
 124   2            break;
 125   2          case 0x01:    //左右点动
 126   2            if ((channel_2 == 1) ||(channel_4 == 1))
 127   2            {
 128   3              if (num > 20)
 129   3              {
 130   4                channel_4 = 0;
 131   4                channel_2 = 0;
 132   4              }
 133   3            }
 134   2              case 0x0e:    //上下点动时
 135   2            if ((channel_3 == 1) ||(channel_6 == 1))
 136   2            {
 137   3              if (num > 20)
 138   3              {
 139   4                channel_3 = 0;
 140   4                channel_6 = 0;
 141   4              }
 142   3            }
 143   2            break;
 144   2          default:
 145   2                  break;
 146   2        }    
 147   1                 
 148   1      }
 149          
 150          
 151          
 152          /*****************************************************************
 153          *********功能：定时器2中断初始化函数,10us
 154          ******************************************************************/
 155          void timer2_init()    
 156          {
 157   1      /*
 158   1        AUXR |= 0x04; //定时器时钟1T模式  10微秒@6.000MHz
 159   1        T2L = 0xC4;   //设置定时初值
 160   1        T2H = 0xFF;   //设置定时初值
 161   1        AUXR |= 0x10; //定时器2开始计时
 162   1        IE2 |= 0x04;  //开定时器2中断
 163   1      */
 164   1      
 165   1      /*
 166   1        AUXR |= 0x04; //定时器时钟1T模式   10微秒@11.0592MHz
 167   1        T2L = 0x91;   //设置定时初值
 168   1        T2H = 0xFF;   //设置定时初值
 169   1        AUXR |= 0x10; //定时器2开始计时
 170   1        IE2 |= 0x04;  //开定时器2中断
 171   1      */
 172   1      
 173   1        AUXR |= 0x04; //定时器时钟1T模式  10微秒@18.432MHz
 174   1        T2L = 0x48;   //设置定时初值
 175   1        T2H = 0xFF;   //设置定时初值
 176   1        AUXR |= 0x10; //定时器2开始计时
 177   1        IE2 |= 0x04;  //开定时器2中断
 178   1        
C51 COMPILER V9.59.0.0   WIRELESS                                                          03/25/2019 10:21:40 PAGE 4   

 179   1      
 180   1      
 181   1      }
 182          
 183          /*****************************************************************
 184          *********功能：定时器2中断函数
 185          ******************************************************************/
 186          void tm2_isr() interrupt 12  using 2
 187          {
 188   1        count++;
 189   1      //  channel_all_times++;
 190   1        
 191   1      
 192   1      
 193   1      }
 194          /*****************************************************************
 195          *********功能：外部中断0初始化函数
 196          ******************************************************************/
 197          void ext0_init()
 198          {
 199   1        ext_in = 1;    
 200   1          data0 = 0;
 201   1          data1 = 0;
 202   1        IT0 = 0;  //上升沿和下降沿都触发中断
 203   1        EX0 = 1;
 204   1        PX0 = 0;
 205   1      
 206   1      //  EA = 1; 
 207   1      }
 208           
 209          /********************************************************************* 
 210          ************** 功能: 外部中断0服务函数，实现对1501解码 *************** 
 211          ************** 中断功能开启后，边沿触发中断进入此函数 **************** 
 212          *********************************************************************/  
 213          
 214          void  exint0() interrupt 0 // using 0 //1501周期35ms   同步码持续8.5ms
 215          { 
 216   1          // static bit L=0;
 217   1           static bit H=0;
 218   1                  //宅脉冲280us   宽脉冲880us
 219   1          if (ext_in)
 220   1            {  
 221   2             if(h_times<20)
 222   2               return; 
 223   2          
 224   2               l_times = count;
 225   2                 count = 0; 
 226   2      
 227   2             if(l_times<20)
 228   2             {
 229   3               count+=l_times;
 230   3             return;
 231   3             }
 232   2      
 233   2      //       if (l_times > 3000)
 234   2      //         {
 235   2      //            times = 0;
 236   2      //            data0 = 0;
 237   2      //            data1 = 0;
 238   2      //            l_times = 0;
 239   2      //            h_times = 0;
 240   2      //            return ;
C51 COMPILER V9.59.0.0   WIRELESS                                                          03/25/2019 10:21:40 PAGE 5   

 241   2      //         } 
 242   2            
 243   2          
 244   2             
 245   2      
 246   2      
 247   2      
 248   2        if (l_times / h_times >= 25||(l_times>700&&H==1))
 249   2             {    
 250   3                    if (times != 24)
 251   3                    {
 252   4                         times = 0;
 253   4                         data0 = 0;
 254   4                         data1 = 0; 
 255   4                         H = 0;                
 256   4                     }
 257   3              }
 258   2          else
 259   2        if (l_times / h_times >=2)
 260   2             {
 261   3                  if (times < 24)
 262   3                  {
 263   4                      data0 = data0 << 1;
 264   4                  }
 265   3                  else
 266   3                  {
 267   4                      data1 = data1 << 1;
 268   4                  }
 269   3                  times ++;
 270   3                }
 271   2              //低电平时间小于高电平时间，则该位数据为1
 272   2              else
 273   2               if(h_times / l_times >=2)
 274   2                {
 275   3                  if (times < 24)
 276   3                  {
 277   4                      data0 = (data0 << 1) + 1;
 278   4                  }
 279   3                  else
 280   3                  {
 281   4                      data1 = (data1 << 1) + 1;
 282   4                  }
 283   3                  times ++;
 284   3                }
 285   2              l_times = 0;
 286   2              h_times = 0;
 287   2              if(study)
 288   2          {
 289   3            if (times >= 48)
 290   3      
 291   3                 { 
 292   4              EX0=0;
 293   4            key=1 ;
 294   4            times = 0;
 295   4                 }
 296   3          
 297   3          }
 298   2          else
 299   2            {
 300   3                    if (times >= 24)
 301   3              { 
 302   4                  data1 = data0;
C51 COMPILER V9.59.0.0   WIRELESS                                                          03/25/2019 10:21:40 PAGE 6   

 303   4                key=1 ;
 304   4                EX0=0;
 305   4                      times = 0;
 306   4                     }
 307   3          }
 308   2             
 309   2          }
 310   1          else
 311   1         {  
 312   2            h_times = count;
 313   2              count = 0;
 314   2          if(h_times>150)
 315   2             {   
 316   3                 h_times=0;
 317   3                 H = 1;
 318   3                 return;
 319   3              }
 320   2        
 321   2          if(h_times<20)
 322   2          {
 323   3          count+=h_times; 
 324   3          }
 325   2      
 326   2           }
 327   1      
 328   1      
 329   1      
 330   1         
 331   1      }
 332          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    684    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
